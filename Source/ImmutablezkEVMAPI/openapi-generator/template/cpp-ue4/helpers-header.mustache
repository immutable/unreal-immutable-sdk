{{>licenseInfo}}

#pragma once

#include "{{modelNamePrefix}}BaseModel.h"

#include "Serialization/JsonSerializer.h"
#include "Dom/JsonObject.h"
#include "Misc/Base64.h"
#include "PlatformHttp.h"

class IHttpRequest;

typedef TSharedRef<TJsonWriter<>> JsonWriter;

//////////////////////////////////////////////////////////////////////////

class {{dllapi}} F{{unrealModuleName}}HttpFileInput
{
public:
	explicit F{{unrealModuleName}}HttpFileInput(const TCHAR* InFilePath);
	explicit F{{unrealModuleName}}HttpFileInput(const FString& InFilePath);

	// This will automatically set the content type if not already set
	void SetFilePath(const TCHAR* InFilePath);
	void SetFilePath(const FString& InFilePath);

	// Optional if it can be deduced from the FilePath
	void SetContentType(const TCHAR* ContentType);

	F{{unrealModuleName}}HttpFileInput& operator=(const F{{unrealModuleName}}HttpFileInput& Other) = default;
	F{{unrealModuleName}}HttpFileInput& operator=(const FString& InFilePath) { SetFilePath(*InFilePath); return*this; }
	F{{unrealModuleName}}HttpFileInput& operator=(const TCHAR* InFilePath) { SetFilePath(InFilePath); return*this; }

	const FString& GetFilePath() const { return FilePath; }
	const FString& GetContentType() const { return ContentType; }

	// Returns the filename with extension
	FString GetFilename() const;

protected:
	FString FilePath;
	FString ContentType;
};

//////////////////////////////////////////////////////////////////////////

class F{{unrealModuleName}}HttpMultipartFormData
{
protected:
	static const TCHAR* Delimiter;
	static const TCHAR* Newline;

public:
	void SetBoundary(const TCHAR* InBoundary);
	void SetupHttpRequest(const FHttpRequestRef& HttpRequest);

	void AddStringPart(const TCHAR* Name, const TCHAR* Data);
	void AddJsonPart(const TCHAR* Name, const FString& JsonString);
	void AddBinaryPart(const TCHAR* Name, const TArray<uint8>& ByteArray);
	void AddFilePart(const TCHAR* Name, const F{{unrealModuleName}}HttpFileInput& File);

protected:
	void AppendString(const TCHAR* Str);
	const FString& GetBoundary() const;

protected:
	mutable FString Boundary;
	TArray<uint8> FormData;
};

//////////////////////////////////////////////////////////////////////////

// Decodes Base64Url encoded strings, see https://en.wikipedia.org/wiki/Base64#Variants_summary_table
template<typename T>
bool Base64UrlDecode(const FString& Base64String, T& Value)
{
	FString TmpCopy(Base64String);
	TmpCopy.ReplaceInline(TEXT("-"), TEXT("+"));
	TmpCopy.ReplaceInline(TEXT("_"), TEXT("/"));

	return FBase64::Decode(TmpCopy, Value);
}

// Encodes strings in Base64Url, see https://en.wikipedia.org/wiki/Base64#Variants_summary_table
template<typename T>
FString Base64UrlEncode(const T& Value)
{
	FString Base64String = FBase64::Encode(Value);
	Base64String.ReplaceInline(TEXT("+"), TEXT("-"));
	Base64String.ReplaceInline(TEXT("/"), TEXT("_"));
	return Base64String;
}

template<typename T>
inline auto ToString(const T& Value)
	-> typename std::enable_if<std::is_same<decltype(::LexToString(Value)), FString>::value, FString>::type
{
	return ::LexToString(Value);
}

template<typename T>
inline auto ToString(const T& EnumModelValue)
	-> typename std::enable_if<std::is_same<decltype(T::EnumToString(EnumModelValue.Value)), FString>::value, FString>::type
{
	return T::EnumToString(EnumModelValue.Value);
}

inline FString ToString(const F{{unrealModuleName}}Model& Value)
{
	FString String;
	JsonWriter Writer = TJsonWriterFactory<>::Create(&String);
	Value.WriteJson(Writer);
	Writer->Close();
	return String;
}

inline FString ToString(const FDateTime& Value)
{
	return Value.ToIso8601();
}

inline FString ToString(const FGuid& Value)
{
	return Value.ToString(EGuidFormats::DigitsWithHyphens);
}

inline FString ToString(const TArray<uint8>& Value)
{
	return FBase64::Encode(Value);
}

template<typename T>
inline FString ToUrlString(const T& Value)
{
	return FPlatformHttp::UrlEncode(ToString(Value));
}

inline FString ToUrlString(const TArray<uint8>& Value)
{
	return Base64UrlEncode(Value);
}

template<typename T>
inline FString CollectionToUrlString(const TArray<T>& Collection, const TCHAR* Separator)
{
	FString Output;
	if(Collection.Num() == 0)
		return Output;

	Output += ToUrlString(Collection[0]);
	for(int i = 1; i < Collection.Num(); i++)
	{
		Output += FString::Format(TEXT("{0}{1}"), { Separator, *ToUrlString(Collection[i]) });
	}
	return Output;
}

template<typename T>
inline FString CollectionToUrlString_csv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT(","));
}

template<typename T>
inline FString CollectionToUrlString_ssv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT(" "));
}

template<typename T>
inline FString CollectionToUrlString_tsv(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT("\t"));
}

template<typename T>
inline FString CollectionToUrlString_pipes(const TArray<T>& Collection, const TCHAR* BaseName)
{
	return CollectionToUrlString(Collection, TEXT("|"));
}

template<typename T>
inline FString CollectionToUrlString_multi(const TArray<T>& Collection, const TCHAR* BaseName)
{
	FString Output;
	if(Collection.Num() == 0)
		return Output;

	Output += FString::Format(TEXT("{0}={1}"), { FStringFormatArg(BaseName), ToUrlString(Collection[0]) });
	for(int i = 1; i < Collection.Num(); i++)
	{
		Output += FString::Format(TEXT("&{0}={1}"), { FStringFormatArg(BaseName), ToUrlString(Collection[i]) });
	}
	return Output;
}

template <typename T>
inline FString CollectionToUrlString_multi(const TSet<T>& Collection, const TCHAR* BaseName)
{
	FString Output;
	if (Collection.Num() == 0)
	{
		return Output;
	}

	int32 Index = 0;
	for (typename TSet<T>::TConstIterator Iter = Collection.CreateConstIterator(); Iter; ++Iter)
	{
		if (Index == 0)
		{
			Output += FString::Format(TEXT("{0}={1}"), { FStringFormatArg(BaseName), ToUrlString(*Iter) });
			Index++;
			continue;
		}
		Output += FString::Format(TEXT("&{0}={1}"), { FStringFormatArg(BaseName), ToUrlString(*Iter) });
	}
	return Output;
}

//////////////////////////////////////////////////////////////////////////

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FString& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

{{dllapi}} bool ParseDateTime(const FString& DateTimeString, FDateTime& OutDateTime);

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FDateTime& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		return ParseDateTime(TmpValue, Value);
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, FGuid& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		return FGuid::Parse(TmpValue, Value);
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, bool& Value)
{
	bool TmpValue;
	if (JsonValue->TryGetBool(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSharedPtr<FJsonValue>& JsonObjectValue)
{
	JsonObjectValue = JsonValue;
	return true;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSharedPtr<FJsonObject>& JsonObjectValue)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		JsonObjectValue = *Object;
		return true;
	}
	return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<uint8>& Value)
{
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		FBase64::Decode(TmpValue, Value);
		return true;
	}
	else
		return false;
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, F{{unrealModuleName}}Model& Value)
{
	return Value.FromJson(JsonValue);
}

template<typename T, typename std::enable_if<!std::is_base_of<F{{unrealModuleName}}Model, T>::value, int>::type = 0>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, T& Value)
{
	T TmpValue;
	if (JsonValue->TryGetNumber(TmpValue))
	{
		Value = TmpValue;
		return true;
	}
	else
		return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TArray<T>& ArrayValue)
{
	const TArray<TSharedPtr<FJsonValue>>* JsonArray;
	if (JsonValue->TryGetArray(JsonArray))
	{
		bool ParseSuccess = true;
		const int32 Count = JsonArray->Num();
		ArrayValue.Reset(Count);
		for (int i = 0; i < Count; i++)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
			ArrayValue.Emplace(MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template <typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TSet<T>& SetValue)
{
	const TArray<TSharedPtr<FJsonValue>>* JsonArray;
	if (JsonValue->TryGetArray(JsonArray))
	{
		bool ParseSuccess = true;
		const int32 Count = JsonArray->Num();
		SetValue.Reset();
		for (int i = 0; i < Count; i++)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue((*JsonArray)[i], TmpValue);
			SetValue.Emplace(MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, TMap<FString, T>& MapValue)
{
	const TSharedPtr<FJsonObject>* Object;
	if (JsonValue->TryGetObject(Object))
	{
		MapValue.Reset();
		bool ParseSuccess = true;
		for (const auto& It : (*Object)->Values)
		{
			T TmpValue;
			ParseSuccess &= TryGetJsonValue(It.Value, TmpValue);
			MapValue.Emplace(It.Key, MoveTemp(TmpValue));
		}
		return ParseSuccess;
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, T& Value)
{
	const TSharedPtr<FJsonValue> JsonValue = JsonObject->TryGetField(Key);
	if (JsonValue.IsValid() && !JsonValue->IsNull())
	{
		return TryGetJsonValue(JsonValue, Value);
	}
	return false;
}

template<typename T>
inline bool TryGetJsonValue(const TSharedPtr<FJsonObject>& JsonObject, const FString& Key, TOptional<T>& OptionalValue)
{
	const TSharedPtr<FJsonValue> JsonValue = JsonObject->TryGetField(Key);
	if (JsonValue.IsValid() && !JsonValue->IsNull())
	{
		T Value = {};
		if (TryGetJsonValue(JsonValue, Value))
		{
			OptionalValue = Value;
			return true;
		}

		return false;
	}
	// Absence of optional value is not a parsing error.
	// Nullable is handled like optional.
	return true;
}

//////////////////////////////////////////////////////////////////////////

inline void WriteJsonValue(JsonWriter& Writer, const TSharedPtr<FJsonValue>& Value)
{
	if (Value.IsValid())
	{
		FJsonSerializer::Serialize(Value.ToSharedRef(), "", Writer, false);
	}
	else
	{
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
	}
}

inline void WriteJsonValue(JsonWriter& Writer, const TSharedPtr<FJsonObject>& Value)
{
	if (Value.IsValid())
	{
		FJsonSerializer::Serialize(Value.ToSharedRef(), Writer, false);
	}
	else
	{
		Writer->WriteObjectStart();
		Writer->WriteObjectEnd();
	}
}

inline void WriteJsonValue(JsonWriter& Writer, const TArray<uint8>& Value)
{
	Writer->WriteValue(FBase64::Encode(Value));
}

inline void WriteJsonValue(JsonWriter& Writer, const FDateTime& Value)
{
	Writer->WriteValue(Value.ToIso8601());
}

inline void WriteJsonValue(JsonWriter& Writer, const FGuid& Value)
{
	Writer->WriteValue(Value.ToString(EGuidFormats::DigitsWithHyphens));
}

inline void WriteJsonValue(JsonWriter& Writer, const F{{unrealModuleName}}Model& Value)
{
	Value.WriteJson(Writer);
}

template<typename T, typename std::enable_if<!std::is_base_of<F{{unrealModuleName}}Model, T>::value, int>::type = 0>
inline void WriteJsonValue(JsonWriter& Writer, const T& Value)
{
	Writer->WriteValue(Value);
}

template<typename T>
inline void WriteJsonValue(JsonWriter& Writer, const TArray<T>& Value)
{
	Writer->WriteArrayStart();
	for (const auto& Element : Value)
	{
		WriteJsonValue(Writer, Element);
	}
	Writer->WriteArrayEnd();
}

template <typename T>
inline void WriteJsonValue(JsonWriter& Writer, const TSet<T>& Value)
{
	Writer->WriteArrayStart();
	for (const auto& Element : Value)
	{
		WriteJsonValue(Writer, Element);
	}
	Writer->WriteArrayEnd();
}

template<typename T>
inline void WriteJsonValue(JsonWriter& Writer, const TMap<FString, T>& Value)
{
	Writer->WriteObjectStart();
	for (const auto& It : Value)
	{
		Writer->WriteIdentifierPrefix(It.Key);
		WriteJsonValue(Writer, It.Value);
	}
	Writer->WriteObjectEnd();
}

//////////////////////////////////////////////////////////////////////////

inline bool operator ==(const TSharedPtr<FJsonObject>& Left, const TSharedPtr<FJsonObject>& Right)
{
	if (Left->Values.Num() != Right->Values.Num())
	{
		return false;
	}

	TArray<FString> LeftKeys;
	Left->Values.GetKeys(LeftKeys);

	TArray<FString> RightKeys;
	Right->Values.GetKeys(RightKeys);

	if (LeftKeys.Num() != RightKeys.Num())
	{
		return false;
	}

	if (LeftKeys != RightKeys)
	{
		return false;
	}

	TArray<TSharedPtr<FJsonValue>> LeftValues;
	Left->Values.GenerateValueArray(LeftValues);

	TArray<TSharedPtr<FJsonValue>> RightValues;
	Right->Values.GenerateValueArray(RightValues);

	if (LeftValues.Num() != RightValues.Num())
	{
		return false;
	}

	if (LeftValues != RightValues)
	{
		return false;
	}

	return true;
}

inline bool operator !=(const TSharedPtr<FJsonObject>& Left, const TSharedPtr<FJsonObject>& Right)
{
	return !(Left == Right);
}

inline bool operator ==(const TSet<FGuid>& Left, const TSet<FGuid>& Right)
{
	// ToDo: Test

	if (Left.Num() != Right.Num())
	{
		return false;
	}

	return Left.Array() == Right.Array();
}

inline bool operator !=(const TSet<FGuid>& Left, const TSet<FGuid>& Right)
{
	return !(Left == Right);
}

inline bool operator ==(const TMap<FString, FString>& Left, const TMap<FString, FString>& Right)
{
	// ToDo: Test

	if (Left.Num() != Right.Num())
	{
		return false;
	}

	TArray<FString> LeftKeys;
	Left.GetKeys(LeftKeys);

	TArray<FString> RightKeys;
	Right.GetKeys(RightKeys);

	if (LeftKeys.Num() != RightKeys.Num())
	{
		return false;
	}

	if (LeftKeys != RightKeys)
	{
		return false;
	}

	TArray<FString> LeftValues;
	Left.GenerateValueArray(LeftValues);

	TArray<FString> RightValues;
	Right.GenerateValueArray(RightValues);

	if (LeftValues.Num() != RightValues.Num())
	{
		return false;
	}

	if (LeftValues != RightValues)
	{
		return false;
	}

	return true;
}

inline bool operator !=(const TMap<FString, FString>& Left, const TMap<FString, FString>& Right)
{
	return !(Left == Right);
}

inline bool operator ==(const TMap<FString, TSharedPtr<FJsonValue>>& Left, const TMap<FString, TSharedPtr<FJsonValue>>& Right)
{
	// ToDo: Test

	if (Left.Num() != Right.Num())
	{
		return false;
	}

	TArray<FString> LeftKeys;
	Left.GetKeys(LeftKeys);

	TArray<FString> RightKeys;
	Right.GetKeys(RightKeys);

	if (LeftKeys.Num() != RightKeys.Num())
	{
		return false;
	}

	if (LeftKeys != RightKeys)
	{
		return false;
	}

	TArray<TSharedPtr<FJsonValue>> LeftValues;
	Left.GenerateValueArray(LeftValues);

	TArray<TSharedPtr<FJsonValue>> RightValues;
	Right.GenerateValueArray(RightValues);

	if (LeftValues.Num() != RightValues.Num())
	{
		return false;
	}

	for (int32 Index = 0; Index < LeftValues.Num(); ++Index)
	{
		if (*LeftValues[Index] != *RightValues[Index])
		{
			return false;
		}
	}

	return true;
}

inline bool operator !=(const TMap<FString, TSharedPtr<FJsonValue>>& Left, const TMap<FString, TSharedPtr<FJsonValue>>& Right)
{
	return !(Left == Right);
}

//////////////////////////////////////////////////////////////////////////

template <typename T>
TArray<T> GenerateMocks(int32 Count = 10)
{
	static_assert(false);
	return {};
}

template <>
inline TArray<bool> GenerateMocks(int32 Count)
{
	TArray<bool> Result;

	for (int32 Index = 0; Index < Count; ++Index)
	{
		Result.Add(FMath::RandBool());
	}

	return Result;
}

template <>
inline TArray<int32> GenerateMocks(int32 Count)
{
	TArray<int32> Result;

	for (int32 Index = 0; Index < Count; ++Index)
	{
		Result.Add(FMath::RandRange(0, 1000));
	}

	return Result;
}

template <>
inline TArray<double> GenerateMocks(int32 Count)
{
	TArray<double> Result;

	for (int32 Index = 0; Index < Count; ++Index)
	{
		Result.Add(FMath::FRandRange(0, 1000));
	}

	return Result;
}

template <>
inline TArray<FGuid> GenerateMocks(int32 Count)
{
	TArray<FGuid> Result;

	for (int32 Index = 0; Index < Count; ++Index)
	{
		Result.Add(FGuid::NewGuid());
	}

	return Result;
}

template <>
inline TArray<FString> GenerateMocks(int32 Count)
{
	TArray<FString> Result;

	for (int32 Index = 0; Index < Count; ++Index)
	{
		Result.Add(FString::Printf(TEXT("Entry_%d_Mock"), Index));
	}

	return Result;
}

template <>
inline TArray<FDateTime> GenerateMocks(int32 Count)
{
	TArray<FDateTime> Result;

	const FDateTime Now = FDateTime::Now();

	for (int32 Index = 0; Index < Count; ++Index)
	{
		Result.Add(Now);
	}

	return Result;
}

template <>
inline TArray<TArray<FString>> GenerateMocks(int32 Count)
{
	TArray<TArray<FString>> Result;

	for (int32 ArrayIndex = 0; ArrayIndex < Count; ++ArrayIndex)
	{
		TArray<FString> Array;

		for (int32 Index = 0; Index < Count; ++Index)
		{
			Array.Add(FString::Printf(TEXT("Array_%d_Entry_%d_Mock"), ArrayIndex));
		}

		Result.Add(Array);
	}

	return Result;
}

template <>
inline TArray<TSharedPtr<FJsonObject>> GenerateMocks(int32 Count)
{
	TArray<TSharedPtr<FJsonObject>> Result;

	for (int32 Index = 0; Index < Count; ++Index)
	{
		Result.Add(MakeShared<FJsonObject>());
	}

	return Result;
}

template <>
inline TArray<TSet<FGuid>> GenerateMocks(int32 Count)
{
	TArray<TSet<FGuid>> Result;

	for (int32 SetIndex = 0; SetIndex < Count; ++SetIndex)
	{
		TSet<FGuid> Set;

		for (int32 Index = 0; Index < Count; ++Index)
		{
			Set.Add(FGuid::NewGuid());
		}

		Result.Add(Set);
	}

	return Result;
}

template <>
inline TArray<TMap<FString, FString>> GenerateMocks(int32 Count)
{
	TArray<TMap<FString, FString>> Result;

	for (int32 MapIndex = 0; MapIndex < Count; ++MapIndex)
	{
		TMap<FString, FString> Map;

		for (int32 Index = 0; Index < Count; ++Index)
		{
			Map.Add(FString::Printf(TEXT("Map_%d_Key_%d_Mock"), MapIndex, Index), FString::Printf(TEXT("Map_%d_Value_%d_Mock"), MapIndex, Index));
		}

		Result.Add(Map);
	}

	return Result;
}

template <>
inline TArray<TMap<FString, TSharedPtr<FJsonValue>>> GenerateMocks(int32 Count)
{
	TArray<TMap<FString, TSharedPtr<FJsonValue>>> Result;

	for (int32 MapIndex = 0; MapIndex < Count; ++MapIndex)
	{
		TMap<FString, TSharedPtr<FJsonValue>> Map;

		for (int32 Index = 0; Index < Count; ++Index)
		{
			Map.Add(FString::Printf(TEXT("Map_%d_Key_%d_Mock"), MapIndex, Index), MakeShareable(new FJsonValueString(FString::Printf(TEXT("Map_%d_Value_%d_Mock"), MapIndex, Index))));
		}

		Result.Add(Map);
	}

	return Result;
}
