{{>licenseInfo}}

#pragma once

#include "Misc/EnumRange.h"
#include "UObject/ObjectMacros.h"
{{#models}}
{{#model}}
{{#oneOf}}
{{#-first}}
#include "Misc/TVariant.h"
{{/-first}}
{{/oneOf}}
{{/model}}
{{/models}}

#include "{{modelNamePrefix}}BaseModel.h"
#include "{{modelNamePrefix}}Helpers.h"
{{#imports}}
{{{import}}}
{{/imports}}
{{#models}}
{{#model}}
{{#isString}}
{{#isEnum}}
{{#allowableValues}}

UENUM(BlueprintType)
enum class E{{classname}}_{{name}}_Values : uint8
{
	{{#enumVars}}
	{{name}} UMETA(DisplayName = "{{value}}"),
	{{/enumVars}}
	MAX
};

ENUM_RANGE_BY_COUNT(E{{classname}}_{{name}}_Values, E{{classname}}_{{name}}_Values::MAX);
{{/allowableValues}}
{{/isEnum}}
{{/isString}}
{{#vars}}
{{#isEnum}}
{{#allowableValues}}

UENUM(BlueprintType)
enum class E{{classname}}_{{name}} : uint8
{
	{{#enumVars}}
	{{name}} UMETA(DisplayName = "{{value}}"),
	{{/enumVars}}
	MAX
};

ENUM_RANGE_BY_COUNT(E{{classname}}_{{name}}, E{{classname}}_{{name}}::MAX);
{{/allowableValues}}
{{/isEnum}}
{{/vars}}

/*
 * F{{classname}}
{{#description}} *
 * {{.}}
{{/description}} */
class {{dllapi}} F{{classname}} : public F{{unrealModuleName}}Model
{
public:
	virtual ~F{{classname}}() override;

	bool operator ==(const F{{classname}}& Other) const;
	bool operator !=(const F{{classname}}& Other) const;

	virtual bool FromJson(const TSharedPtr<FJsonValue>& JsonValue) override final;
	virtual void WriteJson(JsonWriter& Writer) const override final;

public:
	{{#isString}}
	{{#description}}/* {{{.}}} */
	{{/description}}
	{{#isEnum}}
	{{#allowableValues}}E{{classname}}_{{name}}_Values Value{{#defaultValue}} = {{{.}}}{{/defaultValue}};
	{{/allowableValues}}
	{{/isEnum}}
	{{^isEnum}}
	FString Value{{#defaultValue}} = {{{.}}}{{/defaultValue}};
	{{/isEnum}}
	{{/isString}}
	{{#vars}}
	{{#isEnum}}
	{{^-first}}

	{{/-first}}
	{{#description}}/* {{{.}}} */
	{{/description}}{{^required}}TOptional<{{/required}}E{{classname}}_{{name}}{{^required}}>{{/required}} {{name}}{{#required}}{{#defaultValue}} = {{{.}}}{{/defaultValue}}{{/required}};
	{{/isEnum}}
	{{^isEnum}}
	{{^oneOf}}
	{{^-first}}

	{{/-first}}
	{{#description}}/* {{{.}}} */
	{{/description}}{{^required}}TOptional<{{/required}}{{#isPrimitiveType}}{{{datatype}}}{{/isPrimitiveType}}{{^isPrimitiveType}}{{#isContainer}}{{{baseType}}}<F{{{complexType}}}>{{/isContainer}}{{^isContainer}}F{{{datatype}}}{{/isContainer}}{{/isPrimitiveType}}{{^required}}>{{/required}} {{name}}{{#required}}{{#defaultValue}} = {{{.}}}{{/defaultValue}}{{/required}};
	{{/oneOf}}
	{{/isEnum}}
	{{/vars}}
	{{#oneOf}}
	{{#-first}}
	{{#description}}/* {{{.}}} */
	{{/description}}TVariant<{{#composedSchemas}}{{#oneOf}}{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}{{^-last}}, {{/-last}}{{/oneOf}}{{/composedSchemas}}> OneOf;
	{{/-first}}
	{{/oneOf}}
};

template <>
inline TArray<F{{classname}}> GenerateMocks(int32 Count)
{
	TArray<F{{classname}}> Results;

	F{{classname}} Mock = {};

	{{#isString}}
	{{#isEnum}}
	{{#allowableValues}}
	for (E{{classname}}_{{name}}_Values Value : TEnumRange<E{{classname}}_{{name}}_Values>())
	{
		Mock.Value = Value;
		Results.Add(Mock);
	}
	{{/allowableValues}}
	{{/isEnum}}
	{{/isString}}
	{{#vars}}
	{{#isEnum}}
	{{^required}}
	Results.Add(Mock);
	{{/required}}
	{{#allowableValues}}
	for (E{{classname}}_{{name}} Value : TEnumRange<E{{classname}}_{{name}}>())
	{
		Mock.{{name}} = Value;
		Results.Add(Mock);
	}
	{{/allowableValues}}
	{{/isEnum}}
	{{^isEnum}}
	{{^oneOf}}
	{{#isPrimitiveType}}
	{{#isString}}
	TArray<{{datatype}}> {{name}}Mocks = GenerateMocks<{{datatype}}>();
	for (const {{datatype}}& {{name}}Mock : {{name}}Mocks)
	{
		{{#isUuid}}Mock.{{name}} = {{name}}Mock;{{/isUuid}}{{^isUuid}}Mock.{{name}} = FString::Printf(TEXT("%s_%s"), TEXT("{{name}}"), *{{name}}Mock);{{/isUuid}}
		Results.Add(Mock);
	}
	{{/isString}}
	{{^isString}}
	TArray<{{{datatype}}}> {{name}}Mocks = GenerateMocks<{{{datatype}}}>();
	for (const {{{datatype}}}& {{name}}Mock : {{name}}Mocks)
	{
		Mock.{{name}} = {{name}}Mock;
		Results.Add(Mock);
	}
	{{/isString}}
	{{/isPrimitiveType}}
	{{^isPrimitiveType}}
		{{#isContainer}}
			Mock.{{name}} = GenerateMocks<F{{complexType}}>();
			Results.Add(Mock);
		{{/isContainer}}
		{{^isContainer}}
			TArray<F{{datatype}}> {{name}}Mocks = GenerateMocks<F{{datatype}}>();
			for (const F{{datatype}}& {{name}}Mock : {{name}}Mocks)
			{
				Mock.{{name}} = {{name}}Mock;
				Results.Add(Mock);
			}
		{{/isContainer}}
	{{/isPrimitiveType}}
	{{/oneOf}}
	{{/isEnum}}
	{{^-last}}

	{{/-last}}
	{{/vars}}
	{{#composedSchemas}}
	{{#oneOf}}
	TArray<{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}> {{dataType}}Mocks = GenerateMocks<{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}>();
	for (const {{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}& {{dataType}}Mock : {{dataType}}Mocks)
	{
		Mock.OneOf.Set<{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}>({{dataType}}Mock);
		Results.Add(Mock);
	}
	{{^-last}}

	{{/-last}}
	{{/oneOf}}
	{{/composedSchemas}}

	return Results;
}{{/model}}{{/models}}