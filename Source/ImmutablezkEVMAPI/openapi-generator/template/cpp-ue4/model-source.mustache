{{>licenseInfo}}

#include "{{classname}}.h"
{{#models}}{{#model}}{{#isEnum}}
#include "UObject/Class.h"{{/isEnum}}{{#hasEnums}}#include "UObject/Class.h"{{/hasEnums}}{{/model}}{{/models}}
#include "Templates/SharedPointer.h"

#include "{{modelNamePrefix}}Helpers.h"

{{#models}}
{{#model}}
{{#isEnum}}
inline void WriteJsonValue(JsonWriter& Writer, E{{classname}}_{{name}}_Values Value)
{
	WriteJsonValue(Writer, StaticEnum<E{{classname}}_{{name}}_Values>()->GetNameStringByValue(static_cast<int64>(Value)));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, E{{classname}}_{{name}}_Values Value)
{
	{{#allowableValues}}
	FString EnumNameString;
	if (JsonValue->TryGetString(EnumNameString))
	{
		return StaticEnum<E{{classname}}_{{name}}_Values>()->GetIndexByNameString(EnumNameString) != INDEX_NONE;
	}

	{{/allowableValues}}
	return false;
}

{{/isEnum}}
{{#hasEnums}}
{{#vars}}
{{#isEnum}}
inline void WriteJsonValue(JsonWriter& Writer, E{{classname}}_{{name}} Value)
{
	WriteJsonValue(Writer, StaticEnum<E{{classname}}_{{name}}>()->GetNameStringByValue(static_cast<int64>(Value)));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, E{{classname}}_{{name}} Value)
{
	{{#allowableValues}}
	FString EnumNameString;
	if (JsonValue->TryGetString(EnumNameString))
	{
		return StaticEnum<E{{classname}}_{{name}}>()->GetIndexByNameString(EnumNameString) != INDEX_NONE;
	}

	{{/allowableValues}}
	return false;
}

{{/isEnum}}
{{/vars}}
{{/hasEnums}}
void F{{classname}}::WriteJson(JsonWriter& Writer) const
{
	{{#isString}}WriteJsonValue(Writer, Value);{{/isString}}{{#composedSchemas}}{{#oneOf}}{{^-first}}
	else {{/-first}}if (const {{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}* {{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value = OneOf.TryGet<{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}>())
	{
		WriteJsonValue(Writer, *{{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value);
	}{{/oneOf}}{{/composedSchemas}}{{^oneOf}}{{^isString}}Writer->WriteObjectStart();

	{{#vars}}
	{{#required}}
	Writer->WriteIdentifierPrefix(TEXT("{{baseName}}")); WriteJsonValue(Writer, {{name}});
	{{/required}}
	{{^required}}

	if ({{name}}.IsSet())
	{
		Writer->WriteIdentifierPrefix(TEXT("{{baseName}}")); WriteJsonValue(Writer, {{name}}.GetValue());
	}
	{{/required}}
	{{/vars}}

	Writer->WriteObjectEnd();{{/isString}}{{/oneOf}}
}

bool F{{classname}}::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	{{#isString}}return TryGetJsonValue(JsonValue, Value);{{/isString}}{{#composedSchemas}}{{#oneOf}}{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}} {{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value;
	if (const bool bIs{{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}} = TryGetJsonValue(JsonValue, {{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value))
	{
		OneOf.Set<{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}>({{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value);
		return true;
	}

	{{/oneOf}}{{/composedSchemas}}{{#oneOf}}{{#-last}}return false;{{/-last}}{{/oneOf}}{{^oneOf}}{{^isString}}const TSharedPtr<FJsonObject>* Object;
	if (!JsonValue->TryGetObject(Object))
	{
		return false;
	}

	bool ParseSuccess = true;

	{{#vars}}
	{{#required}}
	{{^isWriteOnly}}ParseSuccess &= {{/isWriteOnly}}TryGetJsonValue(*Object, TEXT("{{baseName}}"), {{name}});
	{{/required}}
	{{^required}}
	ParseSuccess &= TryGetJsonValue(*Object, TEXT("{{baseName}}"), {{name}});
	{{/required}}
	{{/vars}}

	return ParseSuccess;{{/isString}}{{/oneOf}}
}{{/model}}{{/models}}