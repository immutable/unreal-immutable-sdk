{{>licenseInfo}}

#include "{{classname}}.h"

#include "Templates/SharedPointer.h"
#include "UObject/Class.h"
{{#models}}
{{#model}}
{{#hasEnums}}
{{/hasEnums}}{{/model}}
{{/models}}
#include "{{modelNamePrefix}}Helpers.h"

{{#models}}
{{#model}}
{{#isEnum}}
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, E{{classname}}_{{name}}_Values& Value)
{
	{{#allowableValues}}
	FString EnumNameString;
	if (JsonValue->TryGetString(EnumNameString))
	{
		UEnum* Enum = StaticEnum<E{{classname}}_{{name}}_Values>();

		for (E{{classname}}_{{name}}_Values Entry : TEnumRange<E{{classname}}_{{name}}_Values>())
		{
			if (Enum->GetNameStringByValue(static_cast<int64>(Entry)) == EnumNameString)
			{
				Value = Entry;

				return true;
			}
		}
	}

	{{/allowableValues}}
	return false;
}

inline void WriteJsonValue(JsonWriter& Writer, E{{classname}}_{{name}}_Values Value)
{
	WriteJsonValue(Writer, StaticEnum<E{{classname}}_{{name}}_Values>()->GetNameStringByValue(static_cast<int64>(Value)));
}

{{/isEnum}}
{{#hasEnums}}
{{#vars}}
{{#isEnum}}
inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, E{{classname}}_{{name}}& Value)
{
	{{#allowableValues}}
	FString EnumNameString;
	if (JsonValue->TryGetString(EnumNameString))
	{
		UEnum* Enum = StaticEnum<E{{classname}}_{{name}}>();

		for (E{{classname}}_{{name}} Entry : TEnumRange<E{{classname}}_{{name}}>())
		{
			if (Enum->GetNameStringByValue(static_cast<int64>(Entry)) == EnumNameString)
			{
				Value = Entry;

				return true;
			}
		}
	}

	{{/allowableValues}}
	return false;
}

inline void WriteJsonValue(JsonWriter& Writer, E{{classname}}_{{name}} Value)
{
	WriteJsonValue(Writer, StaticEnum<E{{classname}}_{{name}}>()->GetNameStringByValue(static_cast<int64>(Value)));
}

{{/isEnum}}
{{/vars}}
{{/hasEnums}}
F{{classname}}::~F{{classname}}()
{
}

bool F{{classname}}::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	{{#isString}}return TryGetJsonValue(JsonValue, Value);{{/isString}}{{#composedSchemas}}{{#oneOf}}{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}} {{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value;
	if (const bool bIs{{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}} = TryGetJsonValue(JsonValue, {{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value))
	{
		OneOf.Set<{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}>({{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value);
		return true;
	}

	{{/oneOf}}{{/composedSchemas}}{{#oneOf}}{{#-last}}return false;{{/-last}}{{/oneOf}}{{^oneOf}}{{^isString}}const TSharedPtr<FJsonObject>* Object;
	if (!JsonValue->TryGetObject(Object))
	{
		return false;
	}

	bool ParseSuccess = true;

	{{#vars}}
	{{#required}}
	{{^isWriteOnly}}ParseSuccess &= {{/isWriteOnly}}TryGetJsonValue(*Object, TEXT("{{baseName}}"), {{name}});
	{{/required}}
	{{^required}}
	ParseSuccess &= TryGetJsonValue(*Object, TEXT("{{baseName}}"), {{name}});
	{{/required}}
	{{/vars}}

	return ParseSuccess;{{/isString}}{{/oneOf}}
}

void F{{classname}}::WriteJson(JsonWriter& Writer) const
{
	{{#isString}}WriteJsonValue(Writer, Value);{{/isString}}{{#composedSchemas}}{{#oneOf}}{{^-first}}
	else {{/-first}}if (const {{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}* {{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value = OneOf.TryGet<{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}>())
	{
		WriteJsonValue(Writer, *{{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value);
	}{{/oneOf}}{{/composedSchemas}}{{^oneOf}}{{^isString}}Writer->WriteObjectStart();

	{{#vars}}
	{{#required}}
	Writer->WriteIdentifierPrefix(TEXT("{{baseName}}")); WriteJsonValue(Writer, {{name}});
	{{/required}}
	{{^required}}

	if ({{name}}.IsSet())
	{
		Writer->WriteIdentifierPrefix(TEXT("{{baseName}}")); WriteJsonValue(Writer, {{name}}.GetValue());
	}
	{{/required}}
	{{/vars}}

	Writer->WriteObjectEnd();{{/isString}}{{/oneOf}}
}{{/model}}{{/models}}