{{>licenseInfo}}

#include "{{classname}}.h"

#include "{{unrealModuleName}}Module.h"
#include "{{modelNamePrefix}}Helpers.h"

#include "Templates/SharedPointer.h"

{{#models}}{{#model}}
{{#isEnum}}
inline FString ToString(const F{{classname}}::Values& Value)
{
	{{#allowableValues}}
	switch (Value)
	{
	{{#enumVars}}
	case F{{classname}}::Values::{{name}}:
		return TEXT("{{{value}}}");
	{{/enumVars}}
	}
	{{/allowableValues}}

	UE_LOG(Log{{unrealModuleName}}, Error, TEXT("Invalid F{{classname}}::Values Value (%d)"), (int)Value);
	return TEXT("");
}

FString F{{classname}}::EnumToString(const F{{classname}}::Values& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, F{{classname}}::Values& Value)
{
	static TMap<FString, F{{classname}}::Values> StringToEnum = { {{#allowableValues}}{{#enumVars}}
		{ TEXT("{{{value}}}"), F{{classname}}::Values::{{name}} },{{/enumVars}}{{/allowableValues}} };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool F{{classname}}::EnumFromString(const FString& EnumAsString, F{{classname}}::Values& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const F{{classname}}::Values& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, F{{classname}}::Values& Value)
{
	{{#allowableValues}}
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	{{/allowableValues}}
	return false;
}

{{/isEnum}}
{{#hasEnums}}
{{#vars}}
{{#isEnum}}
inline FString ToString(const F{{classname}}::{{{enumName}}}& Value)
{
	{{#allowableValues}}
	switch (Value)
	{
	{{#enumVars}}
	case F{{classname}}::{{{enumName}}}::{{name}}:
		return TEXT("{{{value}}}");
	{{/enumVars}}
	}
	{{/allowableValues}}

	UE_LOG(Log{{unrealModuleName}}, Error, TEXT("Invalid F{{classname}}::{{{enumName}}} Value (%d)"), (int)Value);
	return TEXT("");
}

FString F{{classname}}::EnumToString(const F{{classname}}::{{{enumName}}}& EnumValue)
{
	return ToString(EnumValue);
}

inline bool FromString(const FString& EnumAsString, F{{classname}}::{{{enumName}}}& Value)
{
	static TMap<FString, F{{classname}}::{{{enumName}}}> StringToEnum = { {{#allowableValues}}{{#enumVars}}
		{ TEXT("{{{value}}}"), F{{classname}}::{{{enumName}}}::{{name}} },{{/enumVars}}{{/allowableValues}} };

	const auto Found = StringToEnum.Find(EnumAsString);
	if(Found)
		Value = *Found;

	return Found != nullptr;
}

bool F{{classname}}::EnumFromString(const FString& EnumAsString, F{{classname}}::{{{enumName}}}& EnumValue)
{
	return FromString(EnumAsString, EnumValue);
}

inline void WriteJsonValue(JsonWriter& Writer, const F{{classname}}::{{{enumName}}}& Value)
{
	WriteJsonValue(Writer, ToString(Value));
}

inline bool TryGetJsonValue(const TSharedPtr<FJsonValue>& JsonValue, F{{classname}}::{{{enumName}}}& Value)
{
	{{#allowableValues}}
	FString TmpValue;
	if (JsonValue->TryGetString(TmpValue))
	{
		if(FromString(TmpValue, Value))
			return true;
	}
	{{/allowableValues}}
	return false;
}

{{/isEnum}}
{{/vars}}
{{/hasEnums}}
void F{{classname}}::WriteJson(JsonWriter& Writer) const
{
	{{#isString}}WriteJsonValue(Writer, Value);{{/isString}}{{#composedSchemas}}{{#oneOf}}{{^-first}}
	else {{/-first}}if (const {{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}* {{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value = OneOf.TryGet<{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}>())
	{
		WriteJsonValue(Writer, *{{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value);
	}{{/oneOf}}{{/composedSchemas}}{{^oneOf}}{{^isString}}Writer->WriteObjectStart();

	{{#vars}}
	{{#required}}
	Writer->WriteIdentifierPrefix(TEXT("{{baseName}}")); WriteJsonValue(Writer, {{name}});
	{{/required}}
	{{^required}}

	if ({{name}}.IsSet())
	{
		Writer->WriteIdentifierPrefix(TEXT("{{baseName}}")); WriteJsonValue(Writer, {{name}}.GetValue());
	}
	{{/required}}
	{{/vars}}

	Writer->WriteObjectEnd();{{/isString}}{{/oneOf}}
}

bool F{{classname}}::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	{{#isString}}return TryGetJsonValue(JsonValue, Value);{{/isString}}{{#composedSchemas}}{{#oneOf}}{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}} {{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value;
	if (const bool bIs{{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}} = TryGetJsonValue(JsonValue, {{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value))
	{
		OneOf.Set<{{^isPrimitiveType}}F{{/isPrimitiveType}}{{dataType}}>({{#lambda.pascalcase}}{{dataType}}{{/lambda.pascalcase}}Value);
		return true;
	}

	{{/oneOf}}{{/composedSchemas}}{{#oneOf}}{{#-last}}return false;{{/-last}}{{/oneOf}}{{^oneOf}}{{^isString}}const TSharedPtr<FJsonObject>* Object;
	if (!JsonValue->TryGetObject(Object))
	{
		return false;
	}

	bool ParseSuccess = true;

	{{#vars}}
	{{#required}}
	{{^isWriteOnly}}ParseSuccess &= {{/isWriteOnly}}TryGetJsonValue(*Object, TEXT("{{baseName}}"), {{name}});
	{{/required}}
	{{^required}}
	ParseSuccess &= TryGetJsonValue(*Object, TEXT("{{baseName}}"), {{name}});
	{{/required}}
	{{/vars}}

	return ParseSuccess;
	{{/isString}}
	{{/oneOf}}
}

{{/model}}
{{/models}}